<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YOLOv8 Web Demo</title>
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #f0f2f5; margin: 0; overflow: hidden; }
        .screen { display: none; flex-direction: column; align-items: center; justify-content: center; width: 100%; max-width: 720px; padding: 20px; box-sizing: border-box; }
        .screen.active { display: flex; }
        #loadingScreen p { font-size: 1.2em; color: #333; }
        #video-container { position: relative; width: 640px; height: 480px; background-color: #000; border-radius: 8px; overflow: hidden; margin-bottom: 20px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        video, canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
        .button-group { display: flex; gap: 15px; margin-top: 20px; }
        button { padding: 12px 25px; font-size: 1.1em; border: none; border-radius: 30px; cursor: pointer; background-color: #007bff; color: white; transition: background-color 0.3s, transform 0.2s; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        button:hover { background-color: #0056b3; transform: translateY(-2px); }
        button:disabled { background-color: #cccccc; cursor: not-allowed; box-shadow: none; }
        .error { color: #dc3545; margin-top: 10px; font-weight: bold; }
        #analysisStatusMessage { font-style: italic; color: #777; }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none; /* Default hidden */
            backdrop-filter: blur(5px);
        }
        .modal-content {
            background: #fff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.3);
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            text-align: center;
            position: relative;
            animation: fadeInScale 0.3s ease-out;
            width: 700px; /* Adjust as needed */
        }
        @keyframes fadeInScale {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
        .modal-close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 2em;
            color: #999;
            cursor: pointer;
            line-height: 1;
        }
        .modal-close-btn:hover { color: #666; }
        .modal-content h3 { color: #333; margin-bottom: 15px; font-size: 1.5em; }
        .modal-img-container { margin-bottom: 20px; border: 1px solid #eee; border-radius: 8px; overflow: hidden; }
        #modalCanvas { display: block; max-width: 100%; height: auto; }
        .spaceBox, .tipsBox, .scoreBox, #modalChecklistInfo {
            background-color: #f9f9f9;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            text-align: left;
        }
        .spaceBox h3, .tipsBox h3, .scoreBox h3, #modalChecklistInfo h3 {
            color: #007bff;
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 5px;
        }
        .scoreBox p { font-size: 1.3em; font-weight: bold; color: #28a745; }
        #modalFeedbackMessage { font-size: 1.1em; color: #555; margin-top: 20px; font-weight: bold; }
        #modalChecklistInfo ul { list-style: none; padding: 0; margin: 0; }
        #modalChecklistInfo li { margin-bottom: 8px; display: flex; align-items: center; }
        #modalChecklistInfo li input[type="checkbox"] { margin-right: 10px; transform: scale(1.2); }
    </style>
</head>
<body>

<div id="loadingScreen" class="screen active">
    <p>ëª¨ë¸ ë¡œë”© ì¤‘... ì ì‹œë§Œ ê¸°ë‹¤ë ¤ ì£¼ì„¸ìš”.</p>
</div>

<div id="cameraScreen" class="screen">
    <div id="video-container">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="liveCanvas" width="640" height="480"></canvas>
    </div>

    <div class="button-group">
        <button id="analyzeBeforeBtn">ğŸ“¸ í˜„ì¬ ê³µê°„ ë¶„ì„</button>
        <button id="analyzeAfterBtn" disabled>âœ… ì •ë¦¬ í›„ ì ìˆ˜ ë§¤ê¸°ê¸°</button>
    </div>

    <p class="error" id="errorMessage"></p>
    <p id="analysisStatusMessage" style="text-align: center; color: #555; margin-top: 10px;"></p>
</div>

<div id="resultModalOverlay" class="modal-overlay">
    <div class="modal-content">
        <button class="modal-close-btn" onclick="closeResultModal()">&times;</button>
        <h3 id="modalTitle"></h3>
        <div class="modal-img-container">
            <canvas id="modalCanvas" width="640" height="480" style="width: 100%; height: auto;"></canvas>
        </div>
        <div class="spaceBox" id="modalSpaceInfo"></div>
        <div class="tipsBox" id="modalTipsInfo"></div>
        <div class="scoreBox" id="modalScoreInfo"></div>
        <div id="modalChecklistInfo"></div>
        <p id="modalFeedbackMessage"></p>
        <button onclick="closeResultModal()">í™•ì¸</button>
        <button id="resetAppBtn" style="background: #dc3545; display: none;" onclick="resetApplication()">ë‹¤ì‹œ ì‹œì‘</button>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0"></script>
<script src="./models/yolov8n_oiv7_web_model/label.js"></script>
<script>
    const loadingScreen = document.getElementById("loadingScreen");
    const cameraScreen = document.getElementById("cameraScreen");
    const video = document.getElementById("video");
    const liveCanvas = document.getElementById("liveCanvas");
    const liveCtx = liveCanvas.getContext("2d");
    const analyzeBeforeBtn = document.getElementById("analyzeBeforeBtn");
    const analyzeAfterBtn = document.getElementById("analyzeAfterBtn");
    const errorMessage = document.getElementById("errorMessage");
    const analysisStatusMessage = document.getElementById("analysisStatusMessage");

    const resultModalOverlay = document.getElementById("resultModalOverlay");
    const modalTitle = document.getElementById("modalTitle");
    const modalCanvas = document.getElementById("modalCanvas");
    const modalCtx = modalCanvas.getContext("2d");
    const modalSpaceInfo = document.getElementById("modalSpaceInfo");
    const modalTipsInfo = document.getElementById("modalTipsInfo");
    const modalScoreInfo = document.getElementById("modalScoreInfo");
    const modalChecklistInfo = document.getElementById("modalChecklistInfo");
    const modalFeedbackMessage = document.getElementById("modalFeedbackMessage");
    const resetAppBtn = document.getElementById("resetAppBtn");

    let yoloModel = null;
    // ì—¬ê¸°ì—ì„œ window.customLabelsë¥¼ ì°¸ì¡°í•´ì•¼ í•©ë‹ˆë‹¤.
    const customLabels = window.customLabels || []; // ì•ˆì „í•˜ê²Œ ë¹ˆ ë°°ì—´ë¡œ ì´ˆê¸°í™” (label.js ë¡œë”© ì‹¤íŒ¨ ëŒ€ë¹„)
    
    let beforeLabels = [];
    let beforeSnapshotData = null; 
    
    const MODEL_INPUT_SIZE = 640; 
    const IOU_THRESHOLD = 0.45;
    const CONF_THRESHOLD = 0.25; // ì´ ê°’ì„ 0.15 ë˜ëŠ” 0.1ë¡œ ë‚®ì¶°ì„œ ì‹œë„í•´ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

    // Open Images V7 ë ˆì´ë¸” ì¤‘ ë°©ì—ì„œ 'ì–´ì§€ëŸ½í˜'ìœ¼ë¡œ ê°„ì£¼ë  ìˆ˜ ìˆëŠ” ê°ì²´ë“¤ì˜ ëª©ë¡ (ìµœì¢… ì—…ë°ì´íŠ¸ë¨)
    const hardcodedMessyLabels = [
        // ì˜ë¥˜ ë° ê°œì¸ ìš©í’ˆ
        'Backpack', 'Bag', 'Briefcase', 'Clothing', 'Coat', 'Dress', 'Footwear', 'Glove', 'Handbag', 'Hat', 'Helmet',
        'High heels', 'Jacket', 'Jeans', 'Luggage and bags', 'Miniskirt', 'Pants', 'Sandal', 'Scarf', 'Shirt', 'Shoes',
        'Shorts', 'Sock', 'Suit', 'Suitcase', 'Swimwear', 'Tie', 'Trousers', 'Watch',
        'Glasses', 'Sunglasses', 'Earrings', 'Necklace', 'Ring', 'Crown', 'Tiara', 'Fashion accessory',
        'Cosmetics', 'Face powder', 'Hair dryer', 'Hair spray', 'Lipstick', 'Perfume', 'Toothbrush', 'Personal care',

        // ì±… ë° ì‚¬ë¬´ìš©í’ˆ
        'Book', 'Bookcase', 'Paper', 'Magazine', 'Pen', 'Pencil case', 'Pencil sharpener', 'Eraser', 'Ring binder',
        'Office supplies', 'Ruler', 'Stapler', 'Whiteboard', 'Printer', 'Fax',

        // ìŒì‹ ë° ì£¼ë°© ìš©í’ˆ (ë°©ì— ìˆì„ ê²½ìš° ì–´ì§€ëŸ¬ì›€)
        'Apple', 'Banana', 'Bread', 'Cabbage', 'Carrot', 'Cheese', 'Common fig', 'Cucumber', 'Egg (Food)', 'Fruit',
        'Garden Asparagus', 'Grape', 'Grapefruit', 'Lemon', 'Mango', 'Mushroom', 'Orange', 'Pancake', 'Peach', 'Pear',
        'Pineapple', 'Pizza', 'Potato', 'Pumpkin', 'Radish', 'Salad', 'Sandwich', 'Snack', 'Strawberry', 'Sushi', 'Taco',
        'Tart', 'Tomato', 'Vegetable', 'Watermelon', 'Winter melon', 'Zucchini',
        'Beer', 'Coffee', 'Cocktail', 'Drink', 'Juice', 'Milk', 'Tea', 'Wine',
        'Bagel', 'Baked goods', 'Candy', 'Cookie', 'Croissant', 'Dessert', 'Doughnut', 'Hamburger', 'Hot dog', 'Ice cream',
        'Muffin', 'Popcorn', 'Pretzel', 'Submarine sandwich', 'Waffle',
        'Bottle', 'Bottle opener', 'Bowl', 'Can opener', 'Coffee cup', 'Container', 'Cooking spray', 'Cup', 'Drinking straw',
        'Frying pan', 'Jug', 'Kettle', 'Kitchen knife', 'Kitchen utensil', 'Kitchenware', 'Ladle', 'Measuring cup',
        'Mixing bowl', 'Mug', 'Plate', 'Platter', 'Saucer', 'Serving tray', 'Spice rack', 'Spoon', 'Teapot', 'Tin can',
        'Tableware', 'Whisk', 'Wine glass', 'Wok',

        // ê°€êµ¬ ë° ì†Œí’ˆ (ë°©ì¹˜ë  ê²½ìš° ì–´ì§€ëŸ¬ì›€)
        'Chair', 'Couch', 'Bed', 'Desk', 'Nightstand', 'Table', 'Coffee table', 'Kitchen & dining room table', 'Stool',
        'Studio couch', 'Sofa bed', 'Cabinetry', 'Chest of drawers', 'Closet', 'Cupboard', 'Drawer', 'Filing cabinet',
        'Shelf', 'Wardrobe', 'Television', 'Computer keyboard', 'Computer monitor', 'Computer mouse', 'Laptop',
        'Mobile phone', 'Remote control', 'Tablet computer', 'Telephone', 'Ipod', 'Headphones', 'Speaker',
        'Alarm clock', 'Clock', 'Digital clock', 'Wall clock',
        'Lamp', 'Light bulb', 'Flowerpot', 'Houseplant', 'Vase', 'Picture frame', 'Poster', 'Mirror',
        'Pillow', 'Towel', 'Blanket', 'Curtain', 'Window blind',
        'Box', 'Plastic bag', 'Waste container', 

        // ì¥ë‚œê° ë° ìŠ¤í¬ì¸  ìš©í’ˆ
        'Ball', 'Balloon', 'Doll', 'Flying disc', 'Toy', 'Teddy bear',
        'Baseball bat', 'Baseball glove', 'Billiard table', 'Bowling equipment', 'Cricket ball', 'Dumbbell', 'Football',
        'Football helmet', 'Golf ball', 'Golf cart', 'Racket', 'Rugby ball', 'Skateboard', 'Ski', 'Snowboard',
        'Sports equipment', 'Table tennis racket', 'Tennis ball', 'Tennis racket', 'Unicycle', 'Volleyball (Ball)',

        // ê¸°íƒ€ (ë°©ì— ìˆì„ ë²•í•œ ì¡ë™ë‹¤ë‹ˆ)
        'Accordion', 'Axe', 'Band-aid', 'Banjo', 'Barrel', 'Bell pepper', 'Binoculars', 'Blender', 'Bomb', 'Cello', 'Chime',
        'Chisel', 'Chopsticks', 'Coffeemaker', 'Coin', 'Corded phone', 'Crutch', 'Cutting board', 'Dagger', 'Dice',
        'Dishwasher', 'Door handle', 'Drill (Tool)', 'Drum', 'Fountain', 'Gas stove', 'Grinder', 'Guacamole', 'Guitar',
        'Hammer', 'Harmonica', 'Harp', 'Harpsichord', 'Heater', 'Honeycomb', 'Humidifier', 'Jacuzzi', 'Jet ski', 'Kite',
        'Knife', 'Ladder', 'Lantern', 'Light switch', 'Maracas', 'Mechanical fan', 'Medical equipment', 'Microphone',
        'Microwave oven', 'Mixer', 'Musical instrument', 'Musical keyboard', 'Nail (Construction)', 'Oboe', 'Office building',
        'Organ (Musical Instrument)', 'Oven', 'Paddle', 'Paper cutter', 'Paper towel', 'Pianoforte', 'Picnic basket',
        'Pliers', 'Plumbing fixture', 'Power plugs and sockets', 'Pressure cooker', 'Punching bag', 'Ratchet (Device)',
        'Refrigerator', 'Scissors', 'Screwdriver', 'Sewing machine', 'Shower', 'Sink', 'Slow cooker', 'Soap dispenser',
        'Spatula', 'Stethoscope', 'Stop sign', 'Syringe', 'Tank', 'Tap', 'Tool', 'Torch', 'Traffic light', 'Traffic sign',
        'Training bench', 'Treadmill', 'Tripod', 'Trombone', 'Trumpet', 'Turkey', 'Turtle', 'Umbrella', 'Waffle iron', 'Wheelchair', 'Wrench',
        'Wagon', 'Walkie-talkie', 'Water bottle', 'Water heater', 'Water cooler', 'Welding mask', 'Washing machine',
        'Vacuum cleaner', 'Steam iron'
    ];
    
    let messyLabelsForScoring = [];


    function mapLabelToFriendlyName(label) {
        if(!label) return '';
        return label; 
    }

    const tipDictionary = {
        'Book': "ğŸ“š ì±…ì€ ì±…ê½‚ì´ë‚˜ ì„ ë°˜ì— ì •ë¦¬í•´ ì£¼ì„¸ìš”.",
        'Cup': "â˜• ì»µì€ ì”»ì–´ì„œ ê±´ì¡°ëŒ€ì— ë†“ê±°ë‚˜ ìˆ˜ë‚©í•˜ì„¸ìš”.",
        'Bottle': "ğŸ§´ ë³‘ì€ ë‚´ìš©ë¬¼ì„ ë¹„ìš°ê³  ë¶„ë¦¬ìˆ˜ê±°í•˜ê±°ë‚˜ ì œìë¦¬ì— ë³´ê´€í•˜ì„¸ìš”.",
        'Laptop': "ğŸ’» ë…¸íŠ¸ë¶ì€ ì‚¬ìš© í›„ ë‹«ì•„ì„œ ì •í•´ì§„ ìœ„ì¹˜ì— ë†“ìœ¼ì„¸ìš”.",
        'Chair': "ğŸª‘ ì˜ìëŠ” ì‚¬ìš© í›„ ì±…ìƒ ì•„ë˜ë¡œ ë°€ì–´ ë„£ì–´ì£¼ì„¸ìš”.",
        'Backpack': "ğŸ’ ê°€ë°©ì€ ë‚´ìš©ë¬¼ì„ ë¹„ìš°ê³  ì œìë¦¬ì— ê±¸ì–´ë‘ì„¸ìš”.",
        'Mobile phone': "ğŸ“± íœ´ëŒ€í°ì€ ì¶©ì „ ìœ„ì¹˜ë‚˜ ì „ìš© ê±°ì¹˜ëŒ€ì— ë³´ê´€í•˜ì„¸ìš”.",
        'Remote control': "ğŸ•¹ï¸ ë¦¬ëª¨ì»¨ì€ ì œìë¦¬ì— ë‘ê±°ë‚˜ ìˆ˜ë‚©í•¨ì— ë„£ì–´ì£¼ì„¸ìš”.",
        'Computer keyboard': "âŒ¨ï¸ ì‚¬ìš© í›„ì—ëŠ” ì œ ìœ„ì¹˜ì— ë‘ê±°ë‚˜ ì •ë¦¬í•˜ì„¸ìš”.",
        'Mouse': "ğŸ–±ï¸ ì‚¬ìš© í›„ì—ëŠ” ì œ ìœ„ì¹˜ì— ë‘ê±°ë‚˜ ì •ë¦¬í•˜ì„¸ìš”.",
        'Toothbrush': "ğŸª¥ ì¹«ì†”ì€ ì‚¬ìš© í›„ ì¹«ì†”ê½‚ì´ì— ì œëŒ€ë¡œ ë³´ê´€í•˜ì„¸ìš”.",
        'Clothing': "ğŸ‘• ì˜·ì€ ì˜·ì¥ì´ë‚˜ ì„¸íƒ ë°”êµ¬ë‹ˆì— ë„£ì–´ì£¼ì„¸ìš”.",
        'Shoes': "ğŸ‘Ÿ ì‹ ë°œì€ ì‹ ë°œì¥ì— ì •ë¦¬í•´ ì£¼ì„¸ìš”.",
        // 'Dishes'ëŠ” Open Images V7ì— ì—†ì„ ê°€ëŠ¥ì„±ì´ ë†’ìœ¼ë¯€ë¡œ, ê´€ë ¨ ë ˆì´ë¸”ë¡œ ëŒ€ì²´ ê³ ë ¤
        'Plate': "ğŸ½ï¸ ì ‘ì‹œëŠ” ì„¤ê±°ì§€ í›„ ì œìë¦¬ì— ìˆ˜ë‚©í•˜ì„¸ìš”.", // Plateë‚˜ Bowl ë“±ìœ¼ë¡œ ëŒ€ì²´
        'Paper': "ğŸ“„ ì¢…ì´ëŠ” ë¶„ë¥˜í•˜ì—¬ ì¬í™œìš©í•˜ê±°ë‚˜ íŒŒì¼ì— ë³´ê´€í•˜ì„¸ìš”.",
        'Cosmetics': "ğŸ’„ í™”ì¥í’ˆì€ í™”ì¥ëŒ€ì— ì •ëˆí•˜ê±°ë‚˜ ì„œëì— ë³´ê´€í•˜ì„¸ìš”.",
        'Toy': "ğŸ§¸ ì¥ë‚œê°ì€ ë†€ì´ í›„ ì¥ë‚œê° ìƒìì— ì •ë¦¬í•˜ì„¸ìš”.",
        'Waste container': "ğŸ—‘ï¸ ì“°ë ˆê¸°í†µì´ ê°€ë“ ì°¼ë‹¤ë©´ ë¹„ì›Œì£¼ì„¸ìš”.",
        'Pillow': "ğŸ›Œ ë² ê°œëŠ” ì¹¨ëŒ€ ìœ„ì— ê°€ì§€ëŸ°íˆ ë†“ìœ¼ì„¸ìš”.",
        'Towel': "ğŸ›€ ìˆ˜ê±´ì€ ì‚¬ìš© í›„ ë¹¨ë˜í†µì— ë„£ê±°ë‚˜ ê±´ì¡°ëŒ€ì— ë„ì–´ì£¼ì„¸ìš”.",
        'Bag': "ğŸ‘œ ê°€ë°©ì€ ë‚´ìš©ë¬¼ì„ ë¹„ìš°ê³  ì •í•´ì§„ ê³³ì— ë‘ì„¸ìš”.",
        'Food': "ğŸ ìŒì‹ë¬¼ ì“°ë ˆê¸°ëŠ” ì œë•Œ ë²„ë¦¬ê³ , ë‚¨ì€ ìŒì‹ì€ ëƒ‰ì¥ê³ ì— ë³´ê´€í•˜ì„¸ìš”."
    };

    const checklistDictionary = {
        'Book': ["ì±…ê½‚ì´ì— ë„£ê¸°", "ì½ì§€ ì•ŠëŠ” ì±… ë¶„ë¥˜"],
        'Cup': ["ì»µ ì”»ê¸°", "ê±´ì¡°ëŒ€ì— ë†“ê¸°", "ìˆ˜ë‚©í•˜ê¸°"],
        'Bottle': ["ëšœê»‘ ë‹«ê¸°", "ì¬í™œìš©í•¨ì— ë„£ê¸°", "ë‚´ìš©ë¬¼ ë¹„ìš°ê¸°"],
        'Laptop': ["ë®ê°œ ë‹«ê¸°", "ì¶©ì „ê¸° ì •ë¦¬", "ì „ì› ë„ê¸°"],
        'Chair': ["ì •ìœ„ì¹˜ ì •ë ¬", "ì˜ì ìœ„ ë¬¼ê±´ ì •ë¦¬"],
        'Backpack': ["ë‚´ìš©ë¬¼ ë¹„ìš°ê¸°", "ì œìë¦¬ì— ê±¸ê¸°/ë‘ê¸°"],
        'Mobile phone': ["ì¶©ì „ ìœ„ì¹˜ì— ë‘ê¸°", "ê±°ì¹˜ëŒ€ì— ë†“ê¸°"],
        'Remote control': ["ì œìë¦¬ë¡œ ì˜®ê¸°ê¸°"],
        'Computer keyboard': ["ì •ë¦¬ í›„ ì œìë¦¬ì— ë†“ê¸°"],
        'Mouse': ["ì •ë¦¬ í›„ ì œìë¦¬ì— ë†“ê¸°"],
        'Toothbrush': ["ì¹«ì†”ê½‚ì´ì— ë³´ê´€í•˜ê¸°"],
        'Clothing': ["ì˜·ì¥/ì„œëì— ë„£ê¸°", "ì„¸íƒ ë°”êµ¬ë‹ˆì— ë„£ê¸°"],
        'Shoes': ["ì‹ ë°œì¥ì— ë„£ê¸°", "í™ í„¸ê¸°"],
        'Plate': ["ì„¤ê±°ì§€ í•˜ê¸°", "ê±´ì¡°/ìˆ˜ë‚©í•˜ê¸°"], // Plateë‚˜ Bowl ë“±ìœ¼ë¡œ ëŒ€ì²´
        'Paper': ["ë¶„ë¥˜í•˜ì—¬ ì¬í™œìš©", "ì„œë¥˜ì² ì— ì •ë¦¬"],
        'Cosmetics': ["í™”ì¥ëŒ€ì— ì •ëˆí•˜ê¸°", "ì„œëì— ë³´ê´€"],
        'Toy': ["ì¥ë‚œê° ìƒìì— ë„£ê¸°", "ì¢…ë¥˜ë³„ë¡œ ë¶„ë¥˜"],
        'Waste container': ["ì“°ë ˆê¸° ë¹„ìš°ê¸°", "ì“°ë ˆê¸°í†µ ë‹¦ê¸°"],
        'Pillow': ["ì¹¨ëŒ€ ì •ë¦¬í•˜ê¸°", "ë² ê°œ ì»¤ë²„ êµì²´"],
        'Towel': ["ë¹¨ë˜í†µì— ë„£ê¸°", "ê±´ì¡°ëŒ€ì— ë„ê¸°"],
        'Bag': ["ë‚´ìš©ë¬¼ ë¹„ìš°ê¸°", "ì •í•´ì§„ ê³³ì— ë‘ê¸°"],
        'Food': ["ë‚¨ì€ ìŒì‹ ëƒ‰ì¥ê³ ì— ë„£ê¸°", "ìœ í†µê¸°í•œ í™•ì¸"]
    };

    const spaceGroups = {
        'ì±…ìƒ ì£¼ë³€': ["Book", "Laptop", "Mouse", "Computer keyboard", "Cup", "Chair", "Pen", "Paper"],
        'ì¹¨ì‹¤': ["Bed", "Pillow", "Blanket", "Book", "Clothing", "Nightstand", "Wardrobe"], // Wardrobe ì¶”ê°€
        'ì£¼ë°©': ["Cup", "Bottle", "Bowl", "Refrigerator", "Microwave oven", "Plate", "Fork", "Knife", "Spoon", "Oven", "Coffee cup", "Teapot", "Wok", "Frying pan"], // ì£¼ë°© ê´€ë ¨ ì¶”ê°€
        'ê±°ì‹¤': ["Couch", "Television", "Potted plant", "Chair", "Remote control", "Bookcase", "Coffee table", "Vase", "Picture frame", "Lamp", "Rug"], // Lamp, Rug (ì–‘íƒ„ì) ì¶”ê°€
        'ìš•ì‹¤': ["Toilet", "Toothbrush", "Cosmetics", "Mirror", "Towel", "Shower", "Soap dispenser", "Bathtub", "Sink"], // Bathtub, Sink ì¶”ê°€
        'í˜„ê´€/ë³µë„': ["Shoes", "Backpack", "Bag", "Coat", "Hat", "Umbrella"]
    };

    function showScreen(screenId) {
        document.querySelectorAll('.screen').forEach(screen => {
            screen.classList.remove('active');
        });
        document.getElementById(screenId).classList.add('active');
    }

    function openResultModal(title, spaceInfo, tipsInfo, scoreInfo, checklistInfo, feedbackMessage, showResetBtn = false) {
        modalTitle.textContent = title;
        modalSpaceInfo.innerHTML = `<h3>ğŸ  ì˜ˆìƒ ê³µê°„</h3><p>${spaceInfo}</p>`;
        modalTipsInfo.innerHTML = `<h3>ğŸ’¡ ì •ë¦¬ íŒ</h3><p>${tipsInfo}</p>`;
        modalScoreInfo.innerHTML = scoreInfo ? `<h3>âœ¨ ì •ë¦¬ ì ìˆ˜</h3><p>${scoreInfo}</p>` : '';
        modalChecklistInfo.innerHTML = checklistInfo ? `<h3>âœ”ï¸ ì •ë¦¬ ì²´í¬ë¦¬ìŠ¤íŠ¸</h3>${checklistInfo}` : '';
        modalFeedbackMessage.textContent = feedbackMessage;
        resetAppBtn.style.display = showResetBtn ? 'block' : 'none';

        resultModalOverlay.style.display = 'flex';
    }

    function closeResultModal() {
        resultModalOverlay.style.display = 'none';
    }

    function guessSpace(labels) {
        const counts = {};
        for (const key in spaceGroups) {
            // labels ë°°ì—´ì˜ ê° í•­ëª©ì´ spaceGroups[key]ì— í¬í•¨ë˜ëŠ”ì§€ í™•ì¸
            counts[key] = labels.filter(l => spaceGroups[key].includes(l)).length;
        }
        const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);
        if (sorted.length > 0 && sorted[0][1] > 0) {
            return sorted[0][0];
        }
        return "ì•Œ ìˆ˜ ì—†ëŠ” ê³µê°„";
    }

    function generateTips(labels) {
        const uniqueLabels = [...new Set(labels)];
        const tips = uniqueLabels.map(l => tipDictionary[l]).filter(Boolean);
        return tips.length ? tips.join("<br>") : "ğŸ‘ í˜„ì¬ íŠ¹ë³„íˆ ì •ë¦¬í•  ë¬¼ê±´ì´ ê°ì§€ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤!"; // ì¤„ë°”ê¿ˆ ì¶”ê°€
    }

    function calculateScore(before, after) {
        let score = 50;
        let feedback = "";

        const beforeCounts = {};
        before.map(l => l.toLowerCase()).forEach(item => { beforeCounts[item] = (beforeCounts[item] || 0) + 1; });
        const afterCounts = {};
        after.map(l => l.toLowerCase()).forEach(item => { afterCounts[item] = (afterCounts[item] || 0) + 1; });

        let removedMessyCount = 0;
        let addedMessyCount = 0;
        
        // ì–´ì§€ëŸ½í˜ ê°ì²´ì— ëŒ€í•´ì„œë§Œ ë³€í™”ëŸ‰ ê³„ì‚°
        messyLabelsForScoring.forEach(messyLabel => { // messyLabelsForScoringëŠ” ì´ë¯¸ ì†Œë¬¸ì
            const beforeQty = beforeCounts[messyLabel] || 0;
            const afterQty = afterCounts[messyLabel] || 0;

            if (beforeQty > afterQty) {
                removedMessyCount += (beforeQty - afterQty);
            } else if (afterQty > beforeQty) {
                addedMessyCount += (afterQty - beforeQty);
            }
        });

        score += removedMessyCount * 10; // ì–´ì§€ëŸ½í˜ ê°ì²´ ê°ì†Œ ì‹œ ì ìˆ˜ í¬ê²Œ ì¦ê°€
        score -= addedMessyCount * 15; // ì–´ì§€ëŸ½í˜ ê°ì²´ ì¦ê°€ ì‹œ ì ìˆ˜ í¬ê²Œ ê°ì†Œ

        // ì „ì²´ ê°ì²´ ìˆ˜ ë³€í™”ë„ ë°˜ì˜ (ì •ë¦¬ = ë¬¼ê±´ ê°ì†Œ)
        let totalRemoved = 0;
        let totalAdded = 0;
        const allBeforeLabels = new Set([...Object.keys(beforeCounts), ...Object.keys(afterCounts)]);
        allBeforeLabels.forEach(label => {
            const beforeQty = beforeCounts[label] || 0;
            const afterQty = afterCounts[label] || 0;
            if (beforeQty > afterQty) {
                totalRemoved += (beforeQty - afterQty);
            } else if (afterQty > beforeQty) {
                totalAdded += (afterQty - beforeQty);
            }
        });
        score += totalRemoved * 2; // ì „ì²´ ê°ì²´ ê°ì†Œ
        score -= totalAdded * 5; // ì „ì²´ ê°ì²´ ì¦ê°€ (ìƒˆë¡œìš´ ë¬¼ê±´ ìƒê¹€)


        if (score > 100) score = 100;
        if (score < 0) score = 0;

        if (score >= 90) feedback = "ì •ë§ ê¹¨ë—í•˜ê²Œ ì •ë¦¬í–ˆì–´ìš”! í›Œë¥­í•©ë‹ˆë‹¤! ğŸ‰";
        else if (score >= 70) feedback = "ì•„ì£¼ ì˜ ì •ë¦¬í–ˆì–´ìš”! ë‹¤ìŒì—” ë” ì™„ë²½í•˜ê²Œ! ğŸ‘";
        else if (score >= 50) feedback = "ê½¤ ê´œì°®ê²Œ ì •ë¦¬í–ˆë„¤ìš”. ì¡°ê¸ˆë§Œ ë” ë…¸ë ¥í•˜ë©´ ì™„ë²½í•´ì ¸ìš”! ğŸ˜‰";
        else feedback = "ì¡°ê¸ˆ ë” ì •ë¦¬í•´ì•¼ í•  ê²ƒ ê°™ì•„ìš”. ë‹¤ìŒ ë²ˆì—ëŠ” ë” ì˜í•  ìˆ˜ ìˆì–´ìš”! ğŸ’ª";

        return { score: `ğŸ§¹ ì •ë¦¬ ì ìˆ˜: ${score}ì  (ì •ë¦¬ ì „ ${before.length}ê°œ â†’ ì •ë¦¬ í›„ ${after.length}ê°œ ê°ì§€)`, feedback: feedback };
    }


    function generateChecklistHtml(labels) {
        let html = '<ul>'; 
        const uniqueLabels = [...new Set(labels)];
        let hasTasks = false;

        uniqueLabels.forEach(label => {
            const tasks = checklistDictionary[label];
            if (tasks && tasks.length > 0) {
                hasTasks = true;
                html += `<li><strong>${mapLabelToFriendlyName(label)} ê´€ë ¨:</strong></li>`;
                tasks.forEach(task => {
                    html += `<li><input type="checkbox"> ${task}</li>`;
                });
            }
        });

        if (!hasTasks) {
            html += '<li>í˜„ì¬ ì •ë¦¬í•  í•­ëª©ì´ ê°ì§€ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.</li>'; // ë©”ì‹œì§€ ìˆ˜ì •
        }
        html += '</ul>';
        return html;
    }

    function drawBoundingBoxes(targetCtx, targetCanvas, results) {
        targetCtx.clearRect(0, 0, targetCanvas.width, targetCanvas.height);

        // ì´ë¯¸ì§€ ë³µì‚¬ (ìŠ¤ëƒ…ìƒ· ìº”ë²„ìŠ¤ì— ì´ë¯¸ ê·¸ë ¤ì ¸ ìˆìœ¼ë¯€ë¡œ ë‹¤ì‹œ ê·¸ë¦´ í•„ìš” ì—†ìŒ)
        // ë§Œì•½ modalCanvasì— ë¹„ë””ì˜¤ í”„ë ˆì„ì„ ê·¸ë¦¬ëŠ” ë¶€ë¶„ì´ analyzeSnapshotì— ìˆë‹¤ë©´ ì´ ë¶€ë¶„ì€ ìƒëµ ê°€ëŠ¥
        // targetCtx.drawImage(video, 0, 0, targetCanvas.width, targetCanvas.height); 

        results.forEach(prediction => {
            const [x, y, width, height] = prediction.bbox;
            targetCtx.strokeStyle = '#00FF00';
            targetCtx.lineWidth = 3;
            targetCtx.strokeRect(x, y, width, height);

            targetCtx.fillStyle = '#00FF00';
            targetCtx.font = 'bold 18px Noto Sans KR';
            const friendlyLabel = mapLabelToFriendlyName(prediction.class);
            const text = `${friendlyLabel} (${Math.round(prediction.score * 100)}%)`;
            const textWidth = targetCtx.measureText(text).width;
            
            const textBgY = y - 20;
            const textY = y - 5;

            if (textBgY < 0) {
                targetCtx.fillRect(x, y, textWidth + 8, 20);
                targetCtx.fillStyle = '#000000';
                targetCtx.fillText(text, x + 4, y + 15);
            } else {
                targetCtx.fillRect(x, textBgY, textWidth + 8, 20);
                targetCtx.fillStyle = '#000000';
                targetCtx.fillText(text, x + 4, textY);
            }
        });
    }


    async function processYoloOutput(output, imgWidth, imgHeight, labels, iouThreshold, confThreshold) {
        let detections = [];
        // `output`ì€ tf.Tensorì´ë¯€ë¡œ `.arraySync()` ëŒ€ì‹  `.dataSync()`ë¥¼ ì‚¬ìš©
        const data = output.dataSync(); 

        const boxes = [];
        const scores = [];
        const classes = [];

        // YOLOv8 ì¶œë ¥ í…ì„œì˜ shapeë¥¼ ë‹¤ì‹œ í™•ì¸í•©ë‹ˆë‹¤.
        // ì¼ë°˜ì ìœ¼ë¡œ YOLOv8 ì›¹ ëª¨ë¸ (tfjs ë³€í™˜ëœ)ì€ [1, num_predictions, 4 + num_classes] í˜•íƒœë¥¼ ê°€ì§‘ë‹ˆë‹¤.
        // ì˜ˆë¥¼ ë“¤ì–´ [1, 25200, 85] (batch_size, num_bboxes, 4_coords + num_classes)
        const numPredictions = output.shape[1]; // ì˜ˆë¥¼ ë“¤ì–´ 25200
        const numClasses = output.shape[2] - 4; // 4ëŠ” bbox (x,y,w,h)

        console.log(`[processYoloOutput] numPredictions: ${numPredictions}, numClasses: ${numClasses}`);
        if (numPredictions <= 0 || numClasses <= 0) {
            console.warn("ëª¨ë¸ ì¶œë ¥ì˜ ì˜ˆì¸¡ ë˜ëŠ” í´ë˜ìŠ¤ ìˆ˜ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
            tf.dispose(output);
            return detections;
        }

        for (let i = 0; i < numPredictions; i++) {
            const offset = i * (4 + numClasses);
            
            // ë°ì´í„°ê°€ ìœ íš¨í•œ ë²”ìœ„ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸ (í˜¹ì‹œ ëª¨ë¥¼ ì˜¤ë¥˜ ë°©ì§€)
            if (offset + 4 + numClasses > data.length) {
                console.warn(`ë°ì´í„° ë²”ìœ„ ì´ˆê³¼: offset ${offset}, data length ${data.length}`);
                continue;
            }

            const x_center_normalized = data[offset];
            const y_center_normalized = data[offset + 1];
            const width_normalized = data[offset + 2];
            const height_normalized = data[offset + 3];

            let maxScore = -1;
            let classId = -1;
            for (let j = 0; j < numClasses; j++) {
                const classScore = data[offset + 4 + j];
                if (classScore > maxScore) {
                    maxScore = classScore;
                    classId = j;
                }
            }

            if (maxScore >= confThreshold) {
                const x_center_abs = x_center_normalized * imgWidth;
                const y_center_abs = y_center_normalized * imgHeight;
                const width_abs = width_normalized * imgWidth;
                const height_abs = height_normalized * imgHeight;

                const x1 = x_center_abs - width_abs / 2;
                const y1 = y_center_abs - height_abs / 2;
                const x2 = x_center_abs + width_abs / 2;
                const y2 = y_center_abs + height_abs / 2;

                boxes.push([x1, y1, x2, y2]);
                scores.push(maxScore);
                classes.push(classId);
            }
        }
        
        console.log(`[processYoloOutput] Conf threshold (${confThreshold}) ì ìš© í›„ ê°ì§€ëœ ë°•ìŠ¤ ìˆ˜: ${boxes.length}`);

        if (boxes.length === 0) {
            tf.dispose(output);
            return detections; // ê°ì§€ëœ ë°•ìŠ¤ê°€ ì—†ìœ¼ë©´ ë¹ˆ ë°°ì—´ ë°˜í™˜
        }

        const nmsTensor = await tf.image.nonMaxSuppressionAsync(
            tf.tensor2d(boxes),
            tf.tensor1d(scores),
            boxes.length,
            iouThreshold,
            confThreshold
        );

        const nmsIndices = await nmsTensor.array();
        
        console.log(`[processYoloOutput] NMS ì ìš© í›„ ìµœì¢… ì„ íƒëœ ë°•ìŠ¤ ìˆ˜: ${nmsIndices.length}`);


        for (const i of nmsIndices) {
            const x1 = boxes[i][0];
            const y1 = boxes[i][1];
            const x2 = boxes[i][2];
            const y2 = boxes[i][3];

            // labels ë°°ì—´ì˜ ìœ íš¨ì„± ê²€ì‚¬ ì¶”ê°€
            if (classes[i] !== undefined && labels[classes[i]] !== undefined) {
                 detections.push({
                    bbox: [x1, y1, x2 - x1, y2 - y1],
                    class: labels[classes[i]], 
                    score: scores[i]
                });
            } else {
                console.warn(`[processYoloOutput] Undefined classId or label at index ${classes[i]}. Skipping detection.`);
            }
           
        }
        
        tf.dispose(output); // output í…ì„œ í•´ì œ
        tf.dispose(nmsTensor); // NMS ê²°ê³¼ í…ì„œ í•´ì œ

        return detections;
    }


    async function detectLiveObjects() {
        if (!yoloModel || video.paused || video.ended) {
            // ëª¨ë¸ ë¡œë”© ì™„ë£Œë¥¼ ê¸°ë‹¤ë¦¬ê±°ë‚˜ ë¹„ë””ì˜¤ê°€ ì¤€ë¹„ë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¼
            setTimeout(() => requestAnimationFrame(detectLiveObjects), 100); 
            return;
        }

        liveCtx.clearRect(0, 0, liveCanvas.width, liveCanvas.height); 
        
        // requestAnimationFrame ì‚¬ìš©ì„ ê¶Œì¥í•˜ì§€ë§Œ, ì´ ê²½ìš°ëŠ” setTimeoutìœ¼ë¡œ ì œì–´
        // requestAnimationFrame(detectLiveObjects); // ì£¼ì„ ì²˜ë¦¬ëœ ë¶€ë¶„
        
        try {
            const tfImage = tf.browser.fromPixels(video);
            const resized = tf.image.resizeBilinear(tfImage, [MODEL_INPUT_SIZE, MODEL_INPUT_SIZE]);
            const normalized = resized.div(255.0);
            const expanded = normalized.expandDims(0); 

            // YOLOv8 ëª¨ë¸ ì¶”ë¡ 
            const predictions = await yoloModel.executeAsync(expanded);
            
            tfImage.dispose();
            resized.dispose();
            normalized.dispose();
            expanded.dispose();

            // processYoloOutput í•¨ìˆ˜ì—ì„œ predictions í…ì„œê°€ disposeë˜ë„ë¡ ìˆ˜ì •í–ˆìœ¼ë¯€ë¡œ, ì—¬ê¸°ì„œ predictions.dispose()ëŠ” ë¶ˆí•„ìš”
            const results = await processYoloOutput(predictions, video.videoWidth, video.videoHeight, customLabels, IOU_THRESHOLD, CONF_THRESHOLD);
            
            drawBoundingBoxes(liveCtx, liveCanvas, results);

        } catch (e) {
            console.error("ì‹¤ì‹œê°„ ê°ì§€ ì˜¤ë¥˜:", e);
        }
        
        // ë‹¤ìŒ í”„ë ˆì„ì„ ìœ„í•´ ë‹¤ì‹œ í˜¸ì¶œ
        setTimeout(() => requestAnimationFrame(detectLiveObjects), 100); 
    }

    async function analyzeSnapshot(stage) {
        errorMessage.textContent = "";
        analysisStatusMessage.textContent = "ğŸ” ë¶„ì„ ì¤‘...";
        analyzeBeforeBtn.disabled = true;
        analyzeAfterBtn.disabled = true;

        if (!yoloModel) {
            errorMessage.textContent = "â— ëª¨ë¸ì´ ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.";
            analysisStatusMessage.textContent = "";
            analyzeBeforeBtn.disabled = false;
            return;
        }

        try {
            if (video.readyState < 2) {
                throw new Error("ë¹„ë””ì˜¤ í”„ë ˆì„ì´ ì•„ì§ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.");
            }

            modalCanvas.width = video.videoWidth;
            modalCanvas.height = video.videoHeight;
            modalCtx.clearRect(0, 0, modalCanvas.width, modalCanvas.height);
            modalCtx.drawImage(video, 0, 0, modalCanvas.width, modalCanvas.height);

            const tfImage = tf.browser.fromPixels(modalCanvas);
            const resized = tf.image.resizeBilinear(tfImage, [MODEL_INPUT_SIZE, MODEL_INPUT_SIZE]);
            const normalized = resized.div(255.0);
            const expanded = normalized.expandDims(0);

            const predictions = await yoloModel.executeAsync(expanded);
            
            tfImage.dispose();
            resized.dispose();
            normalized.dispose();
            expanded.dispose();

            const results = await processYoloOutput(predictions, modalCanvas.width, modalCanvas.height, customLabels, IOU_THRESHOLD, CONF_THRESHOLD);
            
            const rawLabels = results.map(r => r.class);

            // ë””ë²„ê¹…ì„ ìœ„í•œ ë¡œê·¸ ì¶”ê°€
            console.log("âœ… customLabels.length (analyzeSnapshot):", customLabels.length);
            console.log("ğŸ“· snapshot size:", modalCanvas.width, modalCanvas.height);
            console.log("ğŸ” ê°ì§€ëœ rawLabels (analyzeSnapshot):", rawLabels);

            drawBoundingBoxes(modalCtx, modalCanvas, results);

            const spaceGuess = guessSpace(rawLabels);
            const tips = generateTips(rawLabels);

            let aiMessage = "";
            const messyObjectsDetected = rawLabels
                .filter(label => typeof label === 'string' && messyLabelsForScoring.includes(label.toLowerCase()))
                .length;
            const totalObjectsDetected = rawLabels.length;

            if (totalObjectsDetected === 0) {
                aiMessage = "ğŸ§¼ ì•„ì£¼ ê¹¨ë—í•œ ìƒíƒœì…ë‹ˆë‹¤. ê°ì§€ëœ ë¬¼ê±´ì´ ì—†ìŠµë‹ˆë‹¤."; // ë©”ì‹œì§€ ìˆ˜ì •
            } else if (messyObjectsDetected / totalObjectsDetected < 0.2) {
                aiMessage = "ğŸ§¹ ì •ëˆëœ ìƒíƒœì…ë‹ˆë‹¤.";
            } else {
                aiMessage = "â— ì–´ìˆ˜ì„ í•œ ìƒíƒœì…ë‹ˆë‹¤. ì •ë¦¬ê°€ í•„ìš”í•´ìš”.";
            }

            if (stage === 'before') {
                beforeLabels = rawLabels;
                
                openResultModal(
                    "ğŸ“Œ ì •ë¦¬ ì „ ê³µê°„ ë¶„ì„ ê²°ê³¼",
                    spaceGuess,
                    tips,
                    '',
                    generateChecklistHtml(rawLabels),
                    aiMessage 
                );
                analyzeAfterBtn.disabled = false;
                analyzeBeforeBtn.disabled = false;
            } else {
                const { score, feedback } = calculateScore(beforeLabels, rawLabels);
                
                openResultModal(
                    "âœ¨ ì •ë¦¬ í›„ ì ìˆ˜ ê²°ê³¼",
                    spaceGuess,
                    tips, 
                    score, 
                    generateChecklistHtml(rawLabels),
                    `${feedback} ${aiMessage}`, 
                    true
                );
                analyzeBeforeBtn.disabled = true;
            }
        } catch (e) {
            console.error("ë¶„ì„ ì˜¤ë¥˜:", e);
            errorMessage.textContent = "â— ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: " + e.message;
        } finally {
            analysisStatusMessage.textContent = "";
            if (stage === 'before') { 
                analyzeBeforeBtn.disabled = false;
                analyzeAfterBtn.disabled = false;
            } else { // stage === 'after'ì¼ ë•Œë§Œ ë‹¤ì‹œ ì‹œì‘ ë²„íŠ¼ ë³´ì´ê³ , ë‹¤ë¥¸ ë²„íŠ¼ì€ ë¹„í™œì„±í™” ìœ ì§€
                 // analyzeBeforeBtn.disabled = true; (resetAppBtn ëˆ„ë¥´ê¸° ì „ê¹Œì§€)
            }
        }
    }

    function resetApplication() {
        beforeLabels = [];
        beforeSnapshotData = null;
        analyzeAfterBtn.disabled = true;
        analyzeBeforeBtn.disabled = false;
        closeResultModal(); // ëª¨ë‹¬ ë‹«ê¸°
        errorMessage.textContent = "";
        analysisStatusMessage.textContent = "";
        liveCtx.clearRect(0, 0, liveCanvas.width, liveCanvas.height);
        
        // ì¹´ë©”ë¼ ìŠ¤íŠ¸ë¦¼ì´ í™œì„±í™”ë˜ì–´ ìˆì§€ ì•Šìœ¼ë©´ ë‹¤ì‹œ ì‹œì‘
        if (!video.srcObject || !video.srcObject.active) {
            initCameraAndModel(); 
        }
        showScreen('cameraScreen');
    }

    async function initCameraAndModel() {
        showScreen('loadingScreen');
        errorMessage.textContent = "";

        try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: "environment",
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                } 
            });
            video.srcObject = stream;
            await new Promise((resolve) => {
                video.onloadedmetadata = () => {
                    video.play();
                    resolve();
                };
            });
            liveCanvas.width = video.videoWidth;
            liveCanvas.height = video.videoHeight;
            modalCanvas.width = video.videoWidth;
            modalCanvas.height = video.videoHeight;
            console.log("âœ… Camera initialized. Video dimensions:", video.videoWidth, video.videoHeight);

            analysisStatusMessage.textContent = "ëª¨ë¸ ë¡œë”© ì¤‘...";
            yoloModel = await tf.loadGraphModel('./models/yolov8n_oiv7_web_model/model.json'); 
            console.log("âœ… YOLOv8 Model loaded.");

            // `customLabels`ê°€ window.customLabelsì—ì„œ ì œëŒ€ë¡œ ë¡œë“œë˜ì—ˆëŠ”ì§€ í™•ì¸
            if (!window.customLabels || window.customLabels.length === 0) {
                errorMessage.textContent = "â— ëª¨ë¸ ë ˆì´ë¸”ì„ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. 'label.js' íŒŒì¼ì„ í™•ì¸í•´ì£¼ì„¸ìš”.";
                console.error("Error: window.customLabels is undefined or empty.");
                showScreen('cameraScreen');
                analyzeBeforeBtn.disabled = true; 
                analyzeAfterBtn.disabled = true;
                return;
            }
            console.log("âœ… Custom Labels loaded. Number of labels:", customLabels.length);

            // messyLabelsForScoring ì´ˆê¸°í™” (customLabelsì™€ hardcodedMessyLabelsì˜ êµì§‘í•©)
            messyLabelsForScoring = customLabels.filter(label => 
                hardcodedMessyLabels.includes(label) 
            ).map(label => label.toLowerCase());
            console.log("âœ… Messy Labels for Scoring initialized. Count:", messyLabelsForScoring.length);


            analysisStatusMessage.textContent = "";
            showScreen('cameraScreen');
            detectLiveObjects();

        } catch (error) {
            console.error("Initialization error:", error);
            errorMessage.textContent = "â— ì•± ì´ˆê¸°í™” ì˜¤ë¥˜: " + error.message + " (ì¹´ë©”ë¼ ê¶Œí•œ, ëª¨ë¸ íŒŒì¼ ê²½ë¡œ ë“±ì„ í™•ì¸í•˜ì„¸ìš”)";
            showScreen('cameraScreen');
            analyzeBeforeBtn.disabled = true;
            analyzeAfterBtn.disabled = true;
        }
    }

    analyzeBeforeBtn.addEventListener("click", () => analyzeSnapshot('before'));
    analyzeAfterBtn.addEventListener("click", () => analyzeSnapshot('after'));

    initCameraAndModel();
</script>
</body>
</html>